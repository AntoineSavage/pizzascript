# main.pz

# atom identifiers
# return themselves when unquoted
(def none 'none)
(def false 'false)
(def true 'true)

# useful functions
(def id (func (x) x))
(def apply (func (f x) (f x)))
(def flip (func (f x y) (f y x)))
(def cmp (func (f g) (func (x) (f (g x)))))

# 'if is a macro to choose between alternatives
(def fac (func (n)                  # fac n =
    (if (lte n 1)                   #   if n <= 1
        1                           #   then 1
        (mult n (fac (sub n 1)))    #   else n * fac (n-1)
    )
))

# 'case is a macro to choose between alternatives
(def fib (func (n)          # fib n =
    (case
        ((lte n 0) 0)       #   if n <= 0 then 0
        ((eq n 1) 1)        #   else if n == 1 then 1
        ('true (add         #   else fib (n-1) + fib (n-2)  # TODO Remove atoms?
            (fib (sub n 1))
            (fib (sub n 2)))
        ))
    )
))

# defining new macros
(def my_macro (macro ctx args
    '(ctx args) # call-site ctx unchanged, returns list of quoted args
))

# the following are equivalent
(fac 5)
((func (n) (fac n)) 5)
(apply fac 5)       # apply applies the function to the args
(flip apply 5 fac)  # flip inverts the function's two args
((cmp id fac) 5)    # compose: (id (fac n))
((cmp fac id) 5)    # compose: (fac (id n))

# use quote to convert to (evaluated) list
(quote              # '(ctx
    '(              #   '('list
        0           #       0
        ""          #       ""
        'fac        #       '('ident 'fac)
        '()         #       '('list)
        (dict)      #       '('dict)
        fac         #       'fac
        quote       #       'quote
        (fac 5)     #       '('fac 5)
    )               #   )
)                   # )

# use unquote to convert back to (evaluated) code
(unquote ctx
    '('list             # '(
        0               #   0
        ""              #   ""
        '('ident 'fac)  #   'fac
        '('list)        #   '()
        '('dict)        #   (dict)
        'fac            #   fac
        'quote          #   quote
        '('fac 5)       #   (fac 5) # -> 120
    )                   # )
)

# aliasing (modules, definitions)
(def other other_parent.other_module)
(def func other.func)
(def other_func func)

# get current context
(def new_ctx (get_ctx))

# set current context
(set_ctx new_ctx)

# temporary child context
# does not change the current context
# same evaluation function as interpreter
(do
    (def temp '())
    (print temp)
)

# contexts support all dict operations:
# get, put, delete, update, etc
# adding non-ident keys does not impact resolution
# make symbols private by removing them from ctx
# each child ctx is an immutable fork of the parent ctx

# pizza src/main.pz # source directory is parent of provided file
# with the following folder structure:
#
# main.pz           depends on data.list.lazy.pz and data.set.pz
# data.pz
# data/
#  set.pz           depends on data.pz
#  list.pz          depends on data.pz
#  list/
#    lazy.pz        depends on data.pz and data.list.pz

# load order is as follows:
# 1) compile everything in the source directory (no evaluation yet)
# 2) during compilation, create a tree of:
#   atom -> (NO_INIT | ctx) [: sub-tree], in this case:
#     'main -> NO_INIT
#     'data -> NO_INIT:
#       'set -> NO_INIT
#       'list -> NO_INIT:
#         'lazy -> NO_INIT
#
# 3) call evaluate on the module marked as main, i.e. 'main
# 4) module 'main has finished evaluating, halt

# evaluate(module):
# 1) if the module is already marked as initialized in the tree, return
# 2) mark the module as initialized in the tree with an empty context
# 3) evaluate the module using the aforementioned context, by evaluating each of its statement
#   a) keep track of modifications to the current context
#     i) no need to update the tree on each modification
#   b) if a statement accesses the context of another module:
#     i) update the tree with the current module context
#     ii) call evaluate on the other module
#     iii) finish evaluating the current statement normally
#
# 4) when the module is finished evaluating, update the tree with the current context

# This algorithm ensures that:
# 1) only required modules are ever evaluated
# 2) each required module is evaluated once and only once
# 3) circular dependencies will not cause an infinite recursion
#   a) it MAY cause undefined errors, ex:
#     i) modules A and B have a circular dependency
#     ii) module A uses a symbol of B that was not defined yet
#
#   b) fix this by:
#     i) moving dependant code above any other cross-module statements
#     ii) moving dependant code to a new module
#     iii) only using other module symbols in functions/macros

# error handling
(try
    # result value is returned if no error
    (raise (error))

    # can be absent if finally clause is present
    # result value is returned if error
    (recover e (print "Error: " e))

    # can be absent if recover clause is present
    # result value is ignored
    (finally (print "Finally"))
)

# raise takes 1 or 2 args:
#   - the error to raise (mandatory)
#   - the cause of the error to raise (optional)
#
# it will, in the raised error:
#   - set the cause
#   - set the stack trace:
#       - list of ident/int/int triplets (symbol, line, column), known at compile time

# calling 'raise' will interrupt the evaluation and raise the error
# if not in a 'try', error will percolate up the call stack until a 'try' is reached
# if a 'try' is reached:
#   if the 'recover' clause is not present:
#     invoke the 'finally' clause (MUST be present)
#     keep percolating the error up the call stack
#
#   if the 'recover' clause is present:
#     stop percolating the error up the call stack
#     invoke the 'recover' clause with the error, bind to result
#     invoke the 'finally' clause if present
#     return result
