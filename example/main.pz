# main.pz

# eight types:
#   atoms
#   ints
#   strings
#   identifiers
#   lists
#   dicts
#   functions
#   macros

# atoms
:void
:false
:true
:err # custom atoms are cached
:ok # custom also

# ints
0 1 2 3 10 123
-1 -2 -3

# strings
""
"abc"

# identifiers
'fac
'foo.bar.baz

# lists
'()                     # also: (list)
'(1 2 3 '("abc" :true)) # also: (list 1 2 3 (list "abc" :true))

# dicts (all types can be keys)
(dict)
(dict
    (:void 0)
    (0 "")
    ("" 'dict)
    ('dict '())
    ('() (dict))
    ((dict) (func () '()))
    ((func () '()), (macro ctx args '()))
    ((macro ctx args '()), :void)
)

# functions
(func () :void)
(func (n) (add n 1))
(func (n m) (add n m))

# macros
# functions that receive the call-site context and args (as unevaluated code)
(a context
    # each macro can choose to return code or an evaluated value
)

# applications

# defining new functions
# 'if is a macro to choose between alternatives
(def fac (func (n)                  # fac n =
    (if (lte n 1)                   #   if n <= 1
        1                           #   then 1
        (mult n (fac (sub n 1)))    #   else n * fac (n-1)
    )
))

# 'case is a macro to choose between alternatives
(def fib (func (n)          # fib n =
    (case
        ((lte n 0) 0)       #   if n <= 0 then 0
        ((eq n 1) 1)        #   else if n == 1 then 1
        (:true (add         #   else fib (n-1) + fib (n-2)
            (fib (sub n 1)) 
            (fib (sub n 2)))
        ))
    )
))

# defining new macros
(def my_list (a context
    # return a list containing args evaluated left-to-right
))

# the following are equivalent 
(fac 5)
((func (n) (fac n)) 5)
(apply fac 5)       # apply applies the function to the args
(flip apply 5 fac)  # flip inverts the functio's first and second args
(cmp id fac)        # compose: (id (fac n))
(cmp fac id)        # compose: (fac (id n))

# code and eval are macros to convert between code and lists
(code (fac 5))          # '(env '('fac 5))
(eval env '('fac 5))    # (fac 5) -> 120

# atom synonyms
(def void :void)
(def false :false)
(def true :true)

# alias in current ctx (module, function, etc)
(def other other_parent.other_module)

# unqualified use of function
(def func other.func)

# re-exports function of other module under different name                 
(def other_func other.func)

# circular dependencies are allowed but imported symbols may not be defined yet
# i.e. circular dependencies are okay if only used within functions/macros

# get current context
(get_curr_ctx)

# set current context
(set_curr_ctx ctx)

# contexts support all dict operations:
# get, put, delete, update, etc

# each child ctx is an immutable fork of the parent ctx

# type checks
(is_atom :void)
(is_int 0)
(is_str "")
(is_list '())
(is_ident 'is_ident)
(is_func is_func)
(is_macro is_macro)

# parse X (use same functions as interpreter, inverse of unparse)
(parse_atom ":foo")        # -> :foo, watch out, they are cached!
(parse_int "123")          # -> 123
(parse_str "\"abc\"")      # -> "abc"
(parse_list "'(:void)")    # -> '(:void)
(parse_ident "'fac")       # -> 'fac
(parse_func "(func () (print \"Hello World!\"))")  # -> (func () (print "Hello World!"))
(parse_macro "(macro ctx args '(ctx args))")       # -> (macro ctx args '(ctx args))

# unparse X (use same functions as interprter, inverse of parse)
(unparse_atom :foo)      # -> ":foo"
(unparse_int 123)        # -> "123"
(unparse_str "abc")      # -> "\"abc\""
(unparse_list [:void])   # -> "[:void]"
(unparse_ident 'fac)     # -> "'fac"
(unparse_func (func () (print "Hello World!")))  # -> "(func () (print \"Hello World!\"))"
(unparse_func (macro ctx args '(ctx args)))      # -> "(macro ctx args '(ctx args))"

# functions 'parse' and 'unparse' that do type checks

# identifier <-> atoms
(ident_to_atoms 'foo.bar.baz)       # -> '(:foo :bar :baz)
(atoms_to_ident '(:foo :bar :baz))  # -> 'foo.bar.baz