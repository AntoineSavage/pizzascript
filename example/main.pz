# main.pz

# eight types:
#   atoms
#   ints
#   strings
#   identifiers
#   lists
#   dicts
#   functions
#   macros

# atoms
:void
:false
:true
:err # custom atoms are cached
:ok # custom also

# ints
0 1 2 3 10 123
-1 -2 -3

# strings
""
"abc"

# identifiers
'fac
'foo.bar.baz

# lists
'()                     # also: (list)
'(1 2 3 '("abc" :true)) # also: (list 1 2 3 (list "abc" :true))

# dicts (all types can be keys)
(dict)
(dict
    (:void 0)
    (0 "")
    ("" 'dict)
    ('dict '())
    ('() (dict))
    ((dict) (func () '()))
    ((func () '()), (macro ctx args '()))
    ((macro ctx args '()), :void)
)

# functions
(func () :void)
(func (n) (add n 1))
(func (n m) (add n m))

# macros
# functions that receive the call-site context and args (as unevaluated code)
(a context
    # each macro can choose to return code or an evaluated value
)

# applications

# defining new functions
# 'if is a macro to choose between alternatives
(def fac (func (n)                  # fac n =
    (if (lte n 1)                   #   if n <= 1
        1                           #   then 1
        (mult n (fac (sub n 1)))    #   else n * fac (n-1)
    )
))

# 'case is a macro to choose between alternatives
(def fib (func (n)          # fib n =
    (case
        ((lte n 0) 0)       #   if n <= 0 then 0
        ((eq n 1) 1)        #   else if n == 1 then 1
        (:true (add         #   else fib (n-1) + fib (n-2)
            (fib (sub n 1)) 
            (fib (sub n 2)))
        ))
    )
))

# defining new macros
(def my_list (a context
    # return a list containing args evaluated left-to-right
))

# the following are equivalent 
(fac 5)
((func (n) (fac n)) 5)
(apply fac 5)       # apply applies the function to the args
(flip apply 5 fac)  # flip inverts the functio's first and second args
(cmp id fac)        # compose: (id (fac n))
(cmp fac id)        # compose: (fac (id n))

# code and eval are macros to convert between code and lists
(code (fac 5))          # '(env '('fac 5))
(eval env '('fac 5))    # (fac 5) -> 120

# atom synonyms
(def void :void)
(def false :false)
(def true :true)

# alias in current ctx (module, function, etc)
(def other other_parent.other_module)

# unqualified use of function
(def func other.func)

# re-exports function of other module under different name                 
(def other_func other.func)

# get current context
(get_curr_ctx)

# set current context
(set_curr_ctx ctx)

# contexts support all dict operations:
# get, put, delete, update, etc

# each child ctx is an immutable fork of the parent ctx

# type checks
(is_atom :void)
(is_int 0)
(is_str "")
(is_list '())
(is_ident 'is_ident)
(is_func is_func)
(is_macro is_macro)

# type identification
(type_of :void)     # -> :atom
(type_of 0)         # -> :int
(type_of "")        # -> :str
(type_of '())       # -> :list
(type_of 'is_ident) # -> :ident
(type_of is_func)   # -> :func
(type_of is_macro)  # -> :macro

# parse X (use same functions as interpreter, inverse of unparse)
(parse_atom ":foo")        # -> :foo, watch out, they are cached!
(parse_int "123")          # -> 123
(parse_str "\"abc\"")      # -> "abc"
(parse_list "'(:void)")    # -> '(:void)
(parse_ident "'fac")       # -> 'fac
(parse_func "(func () (print \"Hello World!\"))")  # -> (func () (print "Hello World!"))
(parse_macro "(macro ctx args '(ctx args))")       # -> (macro ctx args '(ctx args))

# unparse X (use same functions as interprter, inverse of parse)
(unparse_atom :foo)      # -> ":foo"
(unparse_int 123)        # -> "123"
(unparse_str "abc")      # -> "\"abc\""
(unparse_list [:void])   # -> "[:void]"
(unparse_ident 'fac)     # -> "'fac"
(unparse_func (func () (print "Hello World!")))  # -> "(func () (print \"Hello World!\"))"
(unparse_func (macro ctx args '(ctx args)))      # -> "(macro ctx args '(ctx args))"

# functions 'parse' and 'unparse' that do type checks

# identifier <-> atoms
(ident_to_atoms 'foo.bar.baz)       # -> '(:foo :bar :baz)
(atoms_to_ident '(:foo :bar :baz))  # -> 'foo.bar.baz

# pizza src/main.pz # source directory is parent of provided file
# with the following folder structure:
#
# main.pz           depends on data.list.lazy.pz and data.set.pz
# data.pz
# data/
#  set.pz           depends on data.pz
#  list.pz          depends on data.pz
#  list/
#    lazy.pz        depends on data.pz and data.list.pz

# load order is as follows:
# 1) compile everything in the source directory (no evaluation yet)
# 2) during compilation, create a tree of:
#   atom -> (NO_INIT | ctx) [: sub-tree], in this case:
#     :main -> NO_INIT
#     :data -> NO_INIT:
#       :set -> NO_INIT
#       :list -> NO_INIT:
#         :lazy -> NO_INIT
#
# 3) call evaluate on the module marked as main, i.e. :main
# 4) module :main has finished evaluating, halt

# evaluate(module):
# 1) if the module is already marked as initialized in the tree, return
# 2) mark the module as initialized in the tree with an empty context
# 3) evaluate the module using the aforementioned context, by evaluating each of its statement
#   a) keep track of modifications to the current context
#     i) no need to update the tree on each modification
#   b) if a statement accesses the context of another module:
#     i) update the tree with the current module context
#     ii) call evaluate on the other module
#     iii) finish evaluating the current statement normally
#
# 4) when the module is finished evaluating, update the tree with the current context

# This algorithm ensures that:
# 1) only required modules are ever evaluated
# 2) each required module is evaluated once and only once
# 3) circular dependencies will not cause an infinite recursion
#   a) it MAY cause undefined errors, ex:
#     i) modules A and B have a circular dependency
#     ii) module A uses a symbol of B that was not defined yet
#
#   b) fix this by:
#     i) moving dependant code above any other cross-module statements
#     ii) moving dependant code to a new module
#     iii) only using other module symbols in functions/macros