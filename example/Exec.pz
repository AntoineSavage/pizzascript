# Exec.pz

# pizza src/Main.pz # source directory is parent of provided main module file
# with the following folder structure:
#
# Main.pz           depends on Data.List.Lazy and Data.Set
# Data.pz
# Data/
#  Set.pz           depends on Data
#  List.pz          depends on Data
#  List/
#    Lazy.pz        depends on Data and Data.List
#
# module idents start with upper-case
# non-module idents start with a lower-case
# this removes ambiguity when accessing stuff fully-qualifiedly
#
# internal module tree:
#   ident -> (NO_INIT | ctx) [: sub-tree]
#
# ex:
#   'Main -> NO_INIT
#   'Data -> NO_INIT:
#     'Set -> NO_INIT
#     'List -> NO_INIT:
#       'Lazy -> NO_INIT
#
# load order is as follows:
# 1) call evaluate on module 'Main, i.e. the module given to the interpreter
# 2) module 'Main has finished evaluating, halt
#
# evaluate(module):
# 1) if the module is already in the context tree (i.e. marked as initialized), return
# 2) compile the module (don't evaluate anything)
# 3) add the module in the context tree with an empty context (i.e. mark as initialized)
#
# 4) evaluate the module using the aforementioned empty context (hereafter the 'current context')
#   a) evaluate each statement, keeping track of modifications to the current context
#     i) no need to update the tree on each modification
#
#   b) if a statement accesses the context of another module:
#     i) update the tree with the current module context
#     ii) call evaluate on the other module
#     iii) finish evaluating the current statement normally
#
# 5) when the module is finished evaluating, update the tree with the current context
#
# This algorithm ensures that:
# 1) required (and only required) modules are compiled and evaluated
# 2) circular dependencies will not cause an infinite recursion
#   a) it MAY cause undefined symbol errors, ex:
#     i) modules A and B have a circular dependency
#     ii) module A uses a symbol of B that was not defined yet
#       A) because evaluation of B paused at its first usage of A
#
#   b) fix this by:
#     i) moving dependant code above any other cross-module statements (i.e. the friend zone)
#     ii) moving dependency code to a new module
#     iii) delay use of other module symbols to function/macro body
#     iv) main guard like in python