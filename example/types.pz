# types.pz

# eight built-in types:
#   nums
#   strings
#   identifiers
#   lists
#   dicts
#   functions
#   macros
#   errors

# nums
0 1 2 3 10 123
-1 -2 -3
0.1 1.1 2.2 10.01 123.123
-1.1 -2.2 -3.3
1.23e123 -123E-123

0b01                # binary
0d0123456789        # decimal
0o01234567          # octal
0x0123456789aBcDeF  # hex (case-insensitive)

# strings
# byte-aligned
# either binary or text (all utf8-encoded)
""
"abc123ABC"
"\\\a\b\d\e\f\n\r\s\t\v\0\x20\u0020\U00020

"\xFF" # binary
"\x20" # text

# escapes:
# \" -> double quote
# \\ -> backslash
# \a -> bell/alert
# \b -> backspace
# \d -> delete
# \e -> escape
# \f -> form feed
# \n -> newline
# \r -> carriage return
# \s -> space
# \t -> tab
# \v -> vertical tab
# \0 -> null byte
# \xDD - one hex byte, ex: \x20
# \uDDDD - one unicode hex codepoint, ex: \u0020
# \UDDDDD - one extended unicode hex codepoint, ex: \U1F600

# identifiers
'fac
'foo.bar.baz

# lists
'()
(list)

'(0 "" 'a '(0 "" 'a) (dict))
(list 0 "" 'a (list 0 "" 'a) (dict))

# dicts (all types can be keys)
# int < string < ident < list < dict < func < macro < error
(dict)
(dict
    (0 "")
    ("" 'dict)
    ('dict '())
    ('() (dict))
    ((dict) (func () '()))
    ((func () '()), (macro ctx args '(ctx args)))
    ((macro ctx args '(ctx args)), 0)
)

# dict syntax when a key is an ident
(def my_dict (dict ('my_field "my_value")))
(my_dict.my_field)

# functions
(func () '())
(func (n) (add n 1))
(func (n m) (add n m))

(func args args) # varargs function, this is how 'list is implemented

# macros
# receive the call-site context and call-site quoted args
# also has an implicit context from when the macro was defined (like all functions)
#   i.e. the implicit and call-site contexts are independant and keep all macro hygienic by default
# returns two things: a call-site context (same or updated), and the macro result, if any
# the macro invocation will update the call-site context with the returned one

(macro ctx () '(ctx '()))
(macro ctx (x) '(ctx x))
(macro ctx (x y) '(ctx x y))
(macro ctx args '((dict) args))

# errors
# fields (all optional)
#    - kind: ident, ex: 'ParseError, 'InputError, 'NetworkError
#    - msg: varargs, ex: "Expected num or str, got: " (typeof input)
#    - data: dict, ex: (dict (my_key 123))

(error)
(error (kind 'InputError))
(error (msg "Invalid input: " 123))
(error (data (dict (n 0)  (s "") (i 'a))))
(error
    (kind 'InputError)
    (msg "Invalid input: " 123))
    (data (dict (n 0) (s "") (i 'a))
)

# type identifiers
(typeof 0)         # -> 'int
(typeof "")        # -> 'str
(typeof 'fac)      # -> 'ident
(typeof '())       # -> 'list
(typeof (dict))    # -> 'dict
(typeof fac)       # -> 'func
(typeof func)      # -> 'macro
(typeof (error))   # -> 'error

# type funcs
(num a_num)     # -> a_num
(num a_str)     # -> (parse_num a_str)
(num x)         # raise (error 'TypeError "Expected num or str, got: " (typeof x))

(str a_str)   # -> a_str
(str a_list)  # -> list-specific format
(str a_dict)  # -> dict-specific format
(str a_error) # -> error-specific format
(str x)       # -> (unparse x)
(str x y z)   # -> apply str (one arg) recursively and concat the result

(ident a_str)   # -> (parse_ident a_str) !!! CACHED !!!
(ident a_ident) # -> a_ident
(ident x)       # raise (error 'TypeError "Expected str or ident, got: " (typeof x))

# parse X (use same functions as interpreter, inverse of unparse)
(parse_num "0")         # -> 0
(parse_str "\"\"")      # -> ""
(parse_ident "'fac")    # -> 'fac !!! CACHED !!!
(parse_list "'()")      # -> '()
(parse_dict "(dict)")   # -> (dict)
(parse_func "(func args args)")                 # -> (func args args)
(parse_macro "(macro ctx args '(ctx args))")    # -> (macro ctx args '(ctx args))
(parse_error "(error)")                         # -> (error)
# on parse error, raise (error (kind 'ParseError) (msg "..."))

# unparse X (use same functions as interprter, inverse of parse)
(unparse_num 0)         # -> "0"
(unparse_str "")        # -> "\"\""
(unparse_ident 'fac)    # -> "'fac"
(unparse_list '())      # -> "'()"
(unparse_dict (dict))   # -> "(dict)"
(unparse_func (func args args))                 # -> "(func args args)"
(unparse_func (macro ctx args '(ctx args)'))    # -> "(macro ctx args '(ctx args))"
(unparse_error (error))                         # -> "(error)"

# functions 'parse' and 'unparse' that do type checks