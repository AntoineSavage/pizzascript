# main.pz

# seven types:
#   ints
#   strings
#   identifiers
#   lists
#   dicts
#   functions
#   macros

# ints
0 1 2 3 10 123
-1 -2 -3

# strings
""
"abc"

# identifiers
'fac
'foo.bar.baz

# lists
'()
(list)

'(0 "" 'a '(0 "" 'a))
(list 0 "" 'a (list 0 "" 'a))

# dicts (all types can be keys)
# int < string < ident < list < dict < func < macro
(dict)
(dict
    (0 "")
    ("" 'dict)
    ('dict '())
    ('() (dict))
    ((dict) (func () '()))
    ((func () '()), (macro ctx args '(ctx args)))
    ((macro ctx args '(ctx args)), 0)
)

# dict syntax when a key is an ident
(def my_dict (dict ('my_field "my_value")))
(my_dict.my_field)

# functions
(func () '())
(func (n) (add n 1))
(func (n m) (add n m))

(func args args) # varargs function, this is how 'list is implemented

# macros
# receive the call-site context and call-site quoted args
# also has an implicit context from when the macro was defined (like all functions)
#   i.e. the implicit and call-site contexts are independant and keep all macro hygienic by default
# returns two things: a call-site context (same or updated), and the macro result, if any
# the macro invocation will update the call-site context with the returned one

(macro ctx () '(ctx '()))
(macro ctx (x) '(ctx x))
(macro ctx (x y) '(ctx x y))
(macro ctx args '((dict) args))

# type checks
(is_int 0)
(is_str "")
(is_ident 'is_ident)
(is_list '())
(is_dict (dict))
(is_func is_func)
(is_macro is_macro)

# type funcs
(int 'b "01")               # binary
(int 'd "0123456789")       # decimal
(int 'o "01234567")         # octal
(int 'x "0123456789abcdef)  # hex

(str "hello")               # -> "hello", no escapes (human readable)
(str non_str)               # -> (unparse x)

(ident 'fac)                # -> 'fac, quote util, ident == id

# type identifiers
(type_of 0)         # -> 'int
(type_of "")        # -> 'str
(type_of 'fac)      # -> 'ident
(type_of '())       # -> 'list
(type_of (dict))    # -> 'dict
(type_of fac)       # -> 'func
(type_of func)      # -> 'macro

# parse X (use same functions as interpreter, inverse of unparse)
(parse_int "0")         # -> 0
(parse_str "\"\"")      # -> ""
(parse_ident "'fac")    # -> 'fac
(parse_list "'()")      # -> '()
(parse_dict "(dict)")   # -> (dict)
(parse_func "(func args args)")                 # -> (func args args)
(parse_macro "(macro ctx args '(ctx args))")    # -> (macro ctx args '(ctx args))

# unparse X (use same functions as interprter, inverse of parse)
(unparse_int 0)         # -> "0"
(unparse_str "")        # -> "\"\""
(unparse_ident 'fac)    # -> "'fac"
(unparse_list '())      # -> "'()"
(unparse_dict (dict))   # -> "(dict)"
(unparse_func (func args args))                 # -> "(func args args)"
(unparse_func (macro ctx args '(ctx args)'))    # -> "(macro ctx args '(ctx args))"

# functions 'parse' and 'unparse' that do type checks